<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Eye Animation 横持ち対応（スワイプ・ピンチ・音声）</title>
<style>
  html, body {
    margin: 0;
    background: black;
    overflow: hidden;
    height: 100%;
    width: 100%;
  }
  #wrapper {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vh;
    height: 100vw;
    transform-origin: top left;
    transform: rotate(90deg) translateY(-100%);
    background: black;
    overflow: hidden;
  }
  canvas {
    width: 100%;
    height: 100%;
    background: black;
    touch-action: none;
  }
</style>
</head>
<body>
<div id="wrapper">
  <canvas id="eyeCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('eyeCanvas');
const ctx = canvas.getContext('2d');

let scale = 1;
let baseScale = 1;
let offsetX = 0;
let offsetY = 0;

const siro = new Image();
const kuro = new Image();
siro.src = "siro.png";
kuro.src = "kuro.png";

const pupilScale = 1.2;
let pupilX = 0;
let pupilY = 0;
let blinkProgress = 0;
let isClosing = true;
const pupilRangeExtra = 150;
let animationRunning = false;
let halfClosed = 36;

function easeInOutSine(t){ return -(Math.cos(Math.PI*t)-1)/2; }

function resizeCanvas(){
  const width = window.innerHeight;
  const height = window.innerWidth;
  canvas.width = width;
  canvas.height = height;
  if(siro.complete){
    const scaleX = canvas.width / siro.width;
    const scaleY = canvas.height / siro.height;
    baseScale = Math.min(scaleX, scaleY);
    if(scale === 1) scale = baseScale;
  }
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', resizeCanvas);
resizeCanvas();

// ピンチ
let lastDist = null;
canvas.addEventListener('touchmove', e=>{
  if(e.touches.length===2){
    e.preventDefault();
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(lastDist){
      scale *= dist / lastDist;
      scale = Math.max(0.5*baseScale, Math.min(2*baseScale, scale));
    }
    lastDist = dist;
  }
}, {passive:false});
canvas.addEventListener('touchend', e=>{
  if(e.touches.length < 2) lastDist = null;
});

// スワイプ
let lastTouchX = null, lastTouchY = null;
canvas.addEventListener('touchstart', e=>{
  if(e.touches.length===1){
    lastTouchX = e.touches[0].clientX;
    lastTouchY = e.touches[0].clientY;
  }
}, {passive:false});
canvas.addEventListener('touchmove', e=>{
  if(e.touches.length===1 && lastTouchX!==null){
    e.preventDefault();
    const dx = e.touches[0].clientX - lastTouchX;
    const dy = e.touches[0].clientY - lastTouchY;
    offsetX += dx;
    offsetY += dy;
    lastTouchX = e.touches[0].clientX;
    lastTouchY = e.touches[0].clientY;
    drawEye();
  }
}, {passive:false});
canvas.addEventListener('touchend', ()=>{ lastTouchX=null; lastTouchY=null; });

function drawEye(){
  if(!siro.complete || !kuro.complete) return;
  ctx.save();
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const centerX = canvas.width/2 + offsetX;
  const centerY = canvas.height/2 + offsetY;

  ctx.translate(centerX, centerY);
  ctx.scale(scale, scale);

  ctx.drawImage(siro, -siro.width/2, -siro.height/2);
  const kuroW = kuro.width * pupilScale;
  const kuroH = kuro.height * pupilScale;
  ctx.drawImage(kuro, pupilX - kuroW/2, pupilY - kuroH/2, kuroW, kuroH);

  const halfEyeH = siro.height/2;
  const eyelidY = halfClosed + (halfEyeH - halfClosed)*blinkProgress;
  ctx.fillStyle = "black";
  ctx.beginPath();
  ctx.moveTo(-siro.width/2, -halfEyeH);
  ctx.lineTo(-siro.width/2, -halfEyeH + eyelidY);
  ctx.quadraticCurveTo(0, -halfEyeH + eyelidY + 20, siro.width/2, -halfEyeH + eyelidY);
  ctx.lineTo(siro.width/2, -halfEyeH);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// まばたき
function blink(times=1){
  return new Promise(resolve=>{
    let count=0;
    function close(){
      isClosing=true;
      animateBlink().then(()=>{
        isClosing=false;
        animateBlink().then(()=>{
          count++;
          if(count<times) setTimeout(close,400);
          else { blinkProgress=0; drawEye(); resolve(); }
        });
      });
    }
    close();
  });
}
function animateBlink(){
  return new Promise(resolve=>{
    const duration=400;
    const start=performance.now();
    function step(time){
      const t=Math.min((time-start)/duration,1);
      blinkProgress = isClosing ? easeInOutSine(t) : easeInOutSine(1-t);
      drawEye();
      if(t<1) requestAnimationFrame(step);
      else resolve();
    }
    requestAnimationFrame(step);
  });
}

// 黒目移動
function moveEyes(){
  return new Promise(resolve=>{
    const range = ((siro.width/2)+pupilRangeExtra)*0.5;
    const duration=4000;
    const repeats=2;
    let count=0, direction=1;
    function animate(direction){
      const startX=pupilX;
      const endX=direction*range;
      const startTime=performance.now();
      function step(time){
        const progress=Math.min((time-startTime)/duration,1);
        pupilX = startX + (endX-startX)*easeInOutSine(progress);
        drawEye();
        if(progress<1) requestAnimationFrame(step);
        else{
          setTimeout(()=>{
            count++;
            if(count<repeats*2) animate(-direction);
            else moveToCenter(resolve);
          },1000);
        }
      }
      requestAnimationFrame(step);
    }
    animate(direction);
  });
}
function moveToCenter(callback){
  const startX=pupilX, startY=pupilY;
  const duration=1500;
  const startTime=performance.now();
  function step(time){
    const progress=Math.min((time-startTime)/duration,1);
    pupilX = startX*(1-easeInOutSine(progress));
    pupilY = startY*(1-easeInOutSine(progress));
    drawEye();
    if(progress<1) requestAnimationFrame(step);
    else if(callback) callback();
  }
  requestAnimationFrame(step);
}
function interruptAndReact(){
  const startY=pupilY;
  const endY=kuro.height*0.3;
  const duration=600;
  const startTime=performance.now();
  function step(time){
    const progress=Math.min((time-startTime)/duration,1);
    pupilY = startY + (endY-startY)*easeInOutSine(progress);
    drawEye();
    if(progress<1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// パターン
async function playPatternB(){ await blink(1); await moveEyes(); await new Promise(r=>setTimeout(r,3000)); }
async function playPatternC(){ await blink(1); drawEye(); await new Promise(r=>setTimeout(r,3000)); }

async function startLoop(){
  if(animationRunning) return;
  animationRunning=true;
  drawEye();
  const next = Math.random()<0.5 ? playPatternB : playPatternC;
  await next();
  animationRunning=false;
  setTimeout(startLoop,1000);
}

// 音声
let audioContext, analyser, dataArray;
let soundThreshold = 35;
async function initMic(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(stream);
    source.connect(analyser);
    analyser.fftSize = 256;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    monitorSound();
  }catch(err){ console.error('マイク拒否:', err); }
}
function monitorSound(){
  if(!analyser) return;
  analyser.getByteFrequencyData(dataArray);
  const avg = dataArray.reduce((a,b)=>a+b,0)/dataArray.length;
  if(avg>soundThreshold) interruptAndReact();
  requestAnimationFrame(monitorSound);
}

// 起動
siro.onload = ()=>{
  resizeCanvas();
  scale = baseScale;
  drawEye();
  initMic();
  startLoop();
};
</script>
</body>
</html>
