<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Eye Animation ver.8（音声停止制御付き）</title>
<style>
  html, body {
    margin: 0;
    background: black;
    overflow: hidden;
    height: 100%;
    width: 100%;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: black;
  }
</style>
</head>
<body>
<canvas id="eyeCanvas"></canvas>

<script>
const canvas = document.getElementById('eyeCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', resizeCanvas);
resizeCanvas();

const siro = new Image();
const kuro = new Image();
siro.src = "siro.png";
kuro.src = "kuro.png";

// ---- 基本パラメータ ----
const pupilScale = 1.2;
let pupilX = 0;
let pupilY = 0;
let blinkProgress = 0;
let isClosing = true;
let pupilRangeExtra = 50;
let reactingToSound = false;
let silenceTimer = null;

// ---- 補間関数 ----
function easeInOutSine(t) {
  return -(Math.cos(Math.PI * t) - 1) / 2;
}

// ---- 音声入力 ----
let audioContext, analyser, dataArray;
let soundThreshold = 35; // 感度（小さいほど敏感）

async function initMic() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(stream);
    source.connect(analyser);
    analyser.fftSize = 256;
    const bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);
    monitorSound();
  } catch (err) {
    console.error('マイクアクセスが拒否されました:', err);
  }
}

function monitorSound() {
  if (!analyser) return;
  analyser.getByteFrequencyData(dataArray);
  const avg = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
  const volume = avg;

  // 音を検知
  if (volume > soundThreshold && !reactingToSound) {
    reactingToSound = true;
    clearTimeout(silenceTimer);
    interruptAndReact(); // 反応処理
  }

  // 音がなくなった場合（音量が閾値の60%未満）
  if (volume < soundThreshold * 0.6 && reactingToSound) {
    clearTimeout(silenceTimer);
    silenceTimer = setTimeout(() => {
      reactingToSound = false;
      moveToCenter(() => {
        if (!animationRunning) startLoop();
      });
    }, 2000); // 🔇静寂後2秒待機
  }

  requestAnimationFrame(monitorSound);
}

// ---- 描画処理 ----
function drawEye() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const siroWidth = siro.width;
  const siroHeight = siro.height;

  ctx.drawImage(siro, centerX - siroWidth / 2, centerY - siroHeight / 2);

  const kuroW = kuro.width * pupilScale;
  const kuroH = kuro.height * pupilScale;
  ctx.drawImage(
    kuro,
    centerX + pupilX - kuroW / 2,
    centerY + pupilY - kuroH / 2,
    kuroW,
    kuroH
  );

  // まぶたマスク
  const baseHalf = canvas.height / 2.2;
  const closeMax = canvas.height * 0.95;
  const eyelidY = baseHalf + (closeMax - baseHalf) * blinkProgress;

  ctx.fillStyle = "black";
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(0, eyelidY);
  ctx.quadraticCurveTo(canvas.width / 2, eyelidY + 80, canvas.width, eyelidY);
  ctx.lineTo(canvas.width, 0);
  ctx.closePath();
  ctx.fill();
}

// ---- まばたき ----
function blink(times = 2, callback) {
  let count = 0;
  function close() {
    if (reactingToSound) return; // 音検知中は停止
    isClosing = true;
    animateBlink(() => {
      isClosing = false;
      animateBlink(() => {
        count++;
        if (count < times) {
          setTimeout(close, 400);
        } else {
          blinkProgress = 0;
          drawEye();
          if (callback) callback();
        }
      });
    });
  }
  close();
}

function animateBlink(onComplete) {
  const duration = 400;
  const start = performance.now();
  function step(time) {
    const t = Math.min((time - start) / duration, 1);
    blinkProgress = isClosing ? easeInOutSine(t) : easeInOutSine(1 - t);
    drawEye();
    if (t < 1) requestAnimationFrame(step);
    else if (onComplete) onComplete();
  }
  requestAnimationFrame(step);
}

// ---- 黒目の移動 ----
function moveEyes(callback) {
  const siroWidth = siro.width;
  const range = (siroWidth / 2) + pupilRangeExtra;
  const duration = 4000;
  const repeats = 2;
  let direction = 1;
  let count = 0;

  function animate(direction, onComplete) {
    if (reactingToSound) return; // 音中断
    const startX = pupilX;
    const endX = direction * range;
    const startTime = performance.now();

    function step(time) {
      if (reactingToSound) return; // 音が鳴ったら停止
      const progress = Math.min((time - startTime) / duration, 1);
      pupilX = startX + (endX - startX) * easeInOutSine(progress);
      drawEye();

      if (progress < 1) {
        requestAnimationFrame(step);
      } else {
        setTimeout(() => {
          count++;
          if (count < repeats * 2) {
            animate(-direction, onComplete);
          } else {
            moveToCenter(onComplete);
          }
        }, 1000);
      }
    }
    requestAnimationFrame(step);
  }
  animate(direction, callback);
}

// ---- 黒目を中央に戻す ----
function moveToCenter(callback) {
  const startX = pupilX;
  const startY = pupilY;
  const duration = 1500;
  const startTime = performance.now();

  function step(time) {
    const progress = Math.min((time - startTime) / duration, 1);
    pupilX = startX * (1 - easeInOutSine(progress));
    pupilY = startY * (1 - easeInOutSine(progress));
    drawEye();
    if (progress < 1) requestAnimationFrame(step);
    else if (callback) callback();
  }
  requestAnimationFrame(step);
}

// ---- 音声反応（下を見る） ----
function interruptAndReact() {
  animationRunning = false;
  const startY = pupilY;
  const endY = kuro.height * 0.3; // 下方向へ少し移動
  const duration = 600;
  const startTime = performance.now();

  function step(time) {
    if (!reactingToSound) return;
    const progress = Math.min((time - startTime) / duration, 1);
    pupilY = startY + (endY - startY) * easeInOutSine(progress);
    drawEye();
    if (progress < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// ---- パターン ----
function playPatternB(onComplete) {
  blink(2, () => moveEyes(() => moveToCenter(() => setTimeout(onComplete, 3000))));
}
function playPatternC(onComplete) {
  blink(2, () => {
    drawEye();
    setTimeout(onComplete, 3000);
  });
}

// ---- ループ ----
let animationRunning = false;
function startLoop() {
  if (animationRunning) return;
  animationRunning = true;

  drawEye();
  const next = Math.random() < 0.5 ? playPatternB : playPatternC;
  next(() => {
    animationRunning = false;
    setTimeout(() => {
      if (!reactingToSound) startLoop();
    }, 1000);
  });
}

// ---- 初期起動 ----
siro.onload = () => {
  drawEye();
  initMic();
  startLoop();
};
</script>
</body>
</html>