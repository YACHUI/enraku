<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no">
<title>Half-Eye Animation（音声反応付き）</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: black;
    overflow: hidden;
    height: 100%;
    width: 100%;
  }
  canvas {
    display: block;
    margin: 0;
    background: black;
  }
</style>
</head>
<body>
<canvas id="eyeCanvas" width="1920" height="1080"></canvas>

<script>
const canvas = document.getElementById('eyeCanvas');
const ctx = canvas.getContext('2d');

const W = 1920;
const H = 1080;
const centerX = W / 2;
const centerY = H / 2;
const eyeRadius = 180;
const pupilRadius = 80;

// 半目マスクの高さ（上半分を隠す）
const maskOffsetY = 40;

// 状態管理
let currentAnim = null;
let isReactingToSound = false;

// 補間関数（イージング）
function easeInOut(t) {
  return 0.5 - Math.cos(Math.PI * t) / 2;
}

// 黒目位置
let pupil = { x: centerX, y: centerY };

// 白目＋黒目を描画
function drawEye(pupilX, pupilY) {
  ctx.clearRect(0, 0, W, H);

  // 白目
  ctx.beginPath();
  ctx.ellipse(centerX, centerY, eyeRadius * 2, eyeRadius * 1.5, 0, 0, Math.PI * 2);
  ctx.fillStyle = "#ffffff";
  ctx.fill();

  // 黒目
  ctx.beginPath();
  ctx.arc(pupilX, pupilY, pupilRadius, 0, Math.PI * 2);
  ctx.fillStyle = "#111111";
  ctx.fill();

  // 半目マスク（上半分を隠す）
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, W, centerY - maskOffsetY);
}

// アニメーションA（キョロキョロ）
function animA() {
  currentAnim = "A";
  const duration = 3000;
  const start = performance.now();
  const moveDist = eyeRadius - pupilRadius + 20;

  function animate(t) {
    if (isReactingToSound) return;
    const elapsed = t - start;
    const progress = Math.min(elapsed / duration, 1);
    const phase = progress * 4 * Math.PI; // 2往復
    const offset = Math.sin(phase) * moveDist * easeInOut(progress);
    drawEye(centerX + offset, centerY);
    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      drawEye(centerX, centerY);
      scheduleNext();
    }
  }
  requestAnimationFrame(animate);
}

// アニメーションB（固定）
function animB() {
  currentAnim = "B";
  drawEye(centerX, centerY);
  setTimeout(scheduleNext, 3000);
}

// アニメーションC（瞬き）
function animC() {
  currentAnim = "C";
  const duration = 400;
  const start = performance.now();

  function animate(t) {
    if (isReactingToSound) return;
    const elapsed = t - start;
    const progress = Math.min(elapsed / duration, 1);
    const blink = progress < 0.5 ? easeInOut(progress * 2) : easeInOut((1 - progress) * 2);

    ctx.clearRect(0, 0, W, H);

    // 白目
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, eyeRadius * 2, eyeRadius * 1.5, 0, 0, Math.PI * 2);
    ctx.fillStyle = "#ffffff";
    ctx.fill();

    // 黒目
    ctx.beginPath();
    ctx.arc(centerX, centerY, pupilRadius, 0, Math.PI * 2);
    ctx.fillStyle = "#111111";
    ctx.fill();

    // まぶた（上下から閉じる）
    const eyelidHeight = H / 2 * blink;
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, W, centerY - eyelidHeight);
    ctx.fillRect(0, centerY + eyelidHeight, W, H);

    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      drawEye(centerX, centerY);
      scheduleNext();
    }
  }
  requestAnimationFrame(animate);
}

// 音声反応アニメ
function reactToSound() {
  if (isReactingToSound) return;
  isReactingToSound = true;

  const downY = centerY + eyeRadius / 2;
  const moveTime = 3000;
  const start = performance.now();

  function animate(t) {
    const elapsed = t - start;
    const progress = Math.min(elapsed / moveTime, 1);
    const y = centerY + easeInOut(progress) * (downY - centerY);
    drawEye(centerX, y);

    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      // 戻す
      const backStart = performance.now();
      function returnAnim(tt) {
        const e2 = tt - backStart;
        const p2 = Math.min(e2 / 1000, 1);
        const y2 = downY - easeInOut(p2) * (downY - centerY);
        drawEye(centerX, y2);
        if (p2 < 1) {
          requestAnimationFrame(returnAnim);
        } else {
          isReactingToSound = false;
          scheduleNext();
        }
      }
      requestAnimationFrame(returnAnim);
    }
  }
  requestAnimationFrame(animate);
}

// ランダムで次のアニメを選ぶ
function scheduleNext() {
  if (isReactingToSound) return;
  const anims = [animA, animB, animC];
  const next = anims[Math.floor(Math.random() * anims.length)];
  setTimeout(next, 500);
}

// 音声検知
async function startMic() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioCtx.createMediaStreamSource(stream);
    const analyser = audioCtx.createAnalyser();
    analyser.fftSize = 256;
    source.connect(analyser);
    const dataArray = new Uint8Array(analyser.frequencyBinCount);

    function detectSound() {
      analyser.getByteFrequencyData(dataArray);
      const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
      if (avg > 60) { // 音量閾値
        reactToSound();
      }
      requestAnimationFrame(detectSound);
    }
    detectSound();
  } catch (e) {
    console.error('マイクアクセスが拒否されました', e);
  }
}

// 初期化
drawEye(centerX, centerY);
scheduleNext();
startMic();
</script>
</body>
</html>