<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Eye Animation 横持ちフィット対応</title>
<style>
  html, body {
    margin: 0;
    background: black;
    overflow: hidden;
    height: 100%;
    width: 100%;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: black;
  }
</style>
</head>
<body>
<canvas id="eyeCanvas"></canvas>

<script>
const canvas = document.getElementById('eyeCanvas');
const ctx = canvas.getContext('2d');

let scale = 1;
let baseScale = 1; // 自動フィット用の基準スケール

// ---- 画像読み込み ----
const siro = new Image();
const kuro = new Image();
siro.src = "siro.png";
kuro.src = "kuro.png";

// ---- 基本パラメータ ----
const pupilScale = 1.2;
let pupilX = 0;
let pupilY = 0;
let blinkProgress = 0;
let isClosing = true;
const pupilRangeExtra = 150;
let reactingToSound = false;
let animationRunning = false;
let returnTimer = null;

// ---- 補間関数 ----
function easeInOutSine(t) { return -(Math.cos(Math.PI*t)-1)/2; }

// ---- canvasリサイズ + 自動フィット ----
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  if(siro.complete){
    // 横持ち画面に収まるスケール計算
    const scaleX = canvas.width / siro.height; // 回転しているので height を横幅基準に
    const scaleY = canvas.height / siro.width; // 回転しているので width を縦幅基準に
    baseScale = Math.min(scaleX, scaleY);
  }
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', resizeCanvas);
resizeCanvas();

// ---- ピンチで拡縮 ----
let lastDist = null;
canvas.addEventListener('touchmove', e => {
  if(e.touches.length === 2){
    e.preventDefault();
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(lastDist){
      scale *= dist / lastDist;
      scale = Math.max(0.5*baseScale, Math.min(2*baseScale, scale));
    }
    lastDist = dist;
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  if(e.touches.length < 2) lastDist = null;
});

// ---- 描画 ----
function drawEye() {
  if (!siro.complete || !kuro.complete) return;
  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 回転 + スケール
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.rotate(-Math.PI/2); // 90度回転
  ctx.scale(scale, scale);

  const centerX = 0;
  const centerY = 0;

  // 白目
  ctx.drawImage(siro, -siro.width/2, -siro.height/2);

  // 黒目
  const kuroW = kuro.width * pupilScale;
  const kuroH = kuro.height * pupilScale;
  ctx.drawImage(kuro, pupilX - kuroW/2, pupilY - kuroH/2, kuroW, kuroH);

  // まぶた
  const halfEyeH = siro.height / 2;
  const closeMax = halfEyeH * 1.9;
  const eyelidY = halfEyeH + (closeMax - halfEyeH) * blinkProgress;

  ctx.fillStyle = "black";
  ctx.beginPath();
  ctx.moveTo(-siro.width/2, -halfEyeH);
  ctx.lineTo(-siro.width/2, eyelidY - halfEyeH);
  ctx.quadraticCurveTo(0, eyelidY - halfEyeH + 80, siro.width/2, eyelidY - halfEyeH);
  ctx.lineTo(siro.width/2, -halfEyeH);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

// ---- アニメーション関数 ----
function blink(times=1) {
  return new Promise(resolve=>{
    let count=0;
    function close() {
      isClosing=true;
      animateBlink().then(()=>{
        isClosing=false;
        animateBlink().then(()=>{
          count++;
          if(count<times) setTimeout(close,400);
          else { blinkProgress=0; drawEye(); resolve(); }
        });
      });
    }
    close();
  });
}

function animateBlink() {
  return new Promise(resolve=>{
    const duration=400;
    const start=performance.now();
    function step(time){
      if(reactingToSound) return resolve();
      const t=Math.min((time-start)/duration,1);
      blinkProgress = isClosing ? easeInOutSine(t) : easeInOutSine(1-t);
      drawEye();
      if(t<1) requestAnimationFrame(step);
      else resolve();
    }
    requestAnimationFrame(step);
  });
}

// ---- 黒目移動 ----
function moveEyes() {
  return new Promise(resolve=>{
    const range = ((siro.width/2)+pupilRangeExtra) * 0.7;
    const duration=4000;
    const repeats=2;
    let count=0;
    let direction=1;

    function animate(direction){
      const startX=pupilX;
      const endX=direction*range;
      const startTime=performance.now();

      function step(time){
        if(reactingToSound) return resolve();
        const progress=Math.min((time-startTime)/duration,1);
        pupilX = startX + (endX-startX)*easeInOutSine(progress);
        drawEye();
        if(progress<1) requestAnimationFrame(step);
        else{
          setTimeout(()=>{
            count++;
            if(count<repeats*2) animate(-direction);
            else moveToCenter(resolve);
          },1000);
        }
      }
      requestAnimationFrame(step);
    }
    animate(direction);
  });
}

function moveToCenter(callback){
  const startX=pupilX;
  const startY=pupilY;
  const duration=1500;
  const startTime=performance.now();

  function step(time){
    const progress=Math.min((time-startTime)/duration,1);
    pupilX = startX*(1-easeInOutSine(progress));
    pupilY = startY*(1-easeInOutSine(progress));
    drawEye();
    if(progress<1) requestAnimationFrame(step);
    else if(callback) callback();
  }
  requestAnimationFrame(step);
}

function interruptAndReact(){
  const startY = pupilY;
  const endY = kuro.height * 0.3;
  const duration = 600;
  const startTime = performance.now();

  function step(time){
    const progress = Math.min((time-startTime)/duration,1);
    pupilY = startY + (endY-startY)*easeInOutSine(progress);
    drawEye();
    if(progress < 1 && reactingToSound) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// ---- アニメーションパターン ----
async function playPatternB(){ 
  await blink(1); 
  await moveEyes(); 
  await new Promise(r=>setTimeout(r,3000));
}
async function playPatternC(){ 
  await blink(1); 
  drawEye();
  await new Promise(r=>setTimeout(r,3000));
}

// ---- アニメーションループ ----
async function startLoop(){
  if(animationRunning || reactingToSound) return;
  animationRunning=true;
  drawEye();

  const next = Math.random() < 0.5 ? playPatternB : playPatternC;
  await next();

  animationRunning=false;
  if(!reactingToSound) setTimeout(startLoop,1000);
}

// ---- 音声入力 ----
let audioContext, analyser, dataArray;
let soundThreshold = 35;

async function initMic() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(stream);
    source.connect(analyser);
    analyser.fftSize = 256;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    monitorSound();
  } catch (err) { console.error('マイクアクセス拒否:', err); }
}

function monitorSound() {
  if (!analyser) return;
  analyser.getByteFrequencyData(dataArray);
  const avg = dataArray.reduce((a,b)=>a+b,0)/dataArray.length;

  if (avg > soundThreshold && !reactingToSound) {
    reactingToSound = true;
    if (returnTimer) { clearTimeout(returnTimer); returnTimer=null; }
    animationRunning = false;
    interruptAndReact();
  }

  if (avg < soundThreshold*0.6 && reactingToSound) {
    if (!returnTimer) {
      returnTimer = setTimeout(()=>{
        moveToCenter(()=>{
          reactingToSound=false;
          startLoop();
        });
        returnTimer=null;
      }, 3000);
    }
  }

  requestAnimationFrame(monitorSound);
}

// ---- 初期起動 ----
siro.onload = ()=>{
  resizeCanvas(); // 初回フィット
  scale = baseScale;
  drawEye();
  initMic();
  startLoop();
};
</script>
</body>
</html>
