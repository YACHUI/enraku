<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Eye Animation ver.12（スマホ回転+ピンチ対応）</title>
<style>
  html, body {
    margin: 0;
    background: black;
    overflow: hidden;
    height: 100%;
    width: 100%;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: black;
    transform-origin: center center;
    touch-action: none; /* タッチ操作制御 */
  }
</style>
</head>
<body>
<canvas id="eyeCanvas"></canvas>

<script>
const canvas = document.getElementById('eyeCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  adjustOrientation();
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', resizeCanvas);
resizeCanvas();

const siro = new Image();
const kuro = new Image();
siro.src = "siro.png";
kuro.src = "kuro.png";

// ---- 基本パラメータ ----
const pupilScale = 1.2;
let pupilX = 0;
let pupilY = 0;
let blinkProgress = 0;
let isClosing = true;
const pupilRangeExtra = 150;
let reactingToSound = false;
let animationRunning = false;
let returnTimer = null;
let scale = 1; // ピンチ拡大縮小用

// ---- 補間関数 ----
function easeInOutSine(t) { return -(Math.cos(Math.PI*t)-1)/2; }

// ---- スマホ回転補正 ----
function adjustOrientation() {
  let angle = 0;
  if(screen.orientation && screen.orientation.angle !== undefined){
    angle = screen.orientation.angle;
  } else if(window.orientation !== undefined){
    angle = window.orientation;
  }
  canvas.style.transform = `rotate(${-angle}deg)`;
}

// ---- 音声入力 ----
let audioContext, analyser, dataArray;
let soundThreshold = 35;

async function initMic() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(stream);
    source.connect(analyser);
    analyser.fftSize = 256;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    monitorSound();
  } catch (err) { console.error('マイクアクセス拒否:', err); }
}

// ---- 音声監視 ----
function monitorSound() {
  if (!analyser) return;
  analyser.getByteFrequencyData(dataArray);
  const avg = dataArray.reduce((a,b)=>a+b,0)/dataArray.length;

  if (avg > soundThreshold && !reactingToSound) {
    reactingToSound = true;
    if (returnTimer) { clearTimeout(returnTimer); returnTimer=null; }
    animationRunning = false;
    interruptAndReact();
  }

  if (avg < soundThreshold*0.6 && reactingToSound) {
    if (!returnTimer) {
      returnTimer = setTimeout(()=>{
        moveToCenter(()=>{
          reactingToSound=false;
          startLoop();
        });
        returnTimer=null;
      }, 3000);
    }
  }

  requestAnimationFrame(monitorSound);
}

// ---- ピンチ拡大縮小 ----
let lastDistance = 0;
canvas.addEventListener('touchmove', e => {
  if(e.touches.length === 2){
    e.preventDefault();
    const dx = e.touches[0].pageX - e.touches[1].pageX;
    const dy = e.touches[0].pageY - e.touches[1].pageY;
    const distance = Math.hypot(dx, dy);
    if(lastDistance){
      const factor = distance / lastDistance;
      scale *= factor;
      if(scale < 0.5) scale = 0.5;
      if(scale > 3) scale = 3;
      drawEye();
    }
    lastDistance = distance;
  }
});
canvas.addEventListener('touchend', e => { if(e.touches.length < 2) lastDistance=0; });

// ---- 描画 ----
function drawEye() {
  ctx.save();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.scale(scale, scale);
  ctx.translate(-canvas.width/2, -canvas.height/2);

  const centerX = canvas.width/2;
  const centerY = canvas.height/2;
  ctx.drawImage(siro, centerX-siro.width/2, centerY-siro.height/2);
  const kuroW = kuro.width * pupilScale;
  const kuroH = kuro.height * pupilScale;
  ctx.drawImage(kuro, centerX+pupilX - kuroW/2, centerY+pupilY - kuroH/2, kuroW, kuroH);

  const baseHalf = canvas.height/2.2;
  const closeMax = canvas.height*0.95;
  const eyelidY = baseHalf + (closeMax-baseHalf)*blinkProgress;
  ctx.fillStyle="black";
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.lineTo(0,eyelidY);
  ctx.quadraticCurveTo(canvas.width/2, eyelidY+80, canvas.width, eyelidY);
  ctx.lineTo(canvas.width,0);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

// ---- アニメーション関数 ----
function blink(times=1) {
  return new Promise(resolve=>{
    let count=0;
    function close() {
      isClosing=true;
      animateBlink().then(()=>{
        isClosing=false;
        animateBlink().then(()=>{
          count++;
          if(count<times) setTimeout(close,400);
          else { blinkProgress=0; drawEye(); resolve(); }
        });
      });
    }
    close();
  });
}

function animateBlink() {
  return new Promise(resolve=>{
    const duration=400;
    const start=performance.now();
    function step(time){
      if(reactingToSound) return resolve();
      const t=Math.min((time-start)/duration,1);
      blinkProgress = isClosing ? easeInOutSine(t) : easeInOutSine(1-t);
      drawEye();
      if(t<1) requestAnimationFrame(step);
      else resolve();
    }
    requestAnimationFrame(step);
  });
}

// ---- 黒目左右移動 ----
function moveEyes() {
  return new Promise(resolve=>{
    const range = ((siro.width/2)+pupilRangeExtra) * 0.8;
    const duration=4000;
    const repeats=2;
    let count=0;
    let direction=1;

    function animate(direction){
      const startX=pupilX;
      const endX=direction*range;
      const startTime=performance.now();

      function step(time){
        if(reactingToSound) return resolve();
        const progress=Math.min((time-startTime)/duration,1);
        pupilX = startX + (endX-startX)*easeInOutSine(progress);
        drawEye();
        if(progress<1) requestAnimationFrame(step);
        else{
          setTimeout(()=>{
            count++;
            if(count<repeats*2) animate(-direction);
            else moveToCenter(resolve);
          },1000);
        }
      }
      requestAnimationFrame(step);
    }
    animate(direction);
  });
}

function moveToCenter(callback){
  const startX=pupilX;
  const startY=pupilY;
  const duration=1500;
  const startTime=performance.now();

  function step(time){
    const progress=Math.min((time-startTime)/duration,1);
    pupilX = startX*(1-easeInOutSine(progress));
    pupilY = startY*(1-easeInOutSine(progress));
    drawEye();
    if(progress<1) requestAnimationFrame(step);
    else if(callback) callback();
  }
  requestAnimationFrame(step);
}

function interruptAndReact(){
  const startY = pupilY;
  const endY = kuro.height * 0.3;
  const duration = 600;
  const startTime = performance.now();

  function step(time){
    const progress = Math.min((time-startTime)/duration,1);
    pupilY = startY + (endY-startY)*easeInOutSine(progress);
    drawEye();
    if(progress < 1 && reactingToSound) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// ---- アニメーションパターン ----
async function playPatternB(){ 
  await blink(1); 
  await moveEyes(); 
  await new Promise(r=>setTimeout(r,3000));
}
async function playPatternC(){ 
  await blink(1); 
  drawEye();
  await new Promise(r=>setTimeout(r,3000));
}

// ---- アニメーションループ ----
async function startLoop(){
  if(animationRunning || reactingToSound) return;
  animationRunning=true;
  drawEye();

  const next = Math.random() < 0.5 ? playPatternB : playPatternC;
  await next();

  animationRunning=false;
  if(!reactingToSound) setTimeout(startLoop,1000);
}

// ---- 初期起動 ----
siro.onload = ()=>{
  drawEye();
  initMic();
  startLoop();
};
</script>
</body>
</html>
