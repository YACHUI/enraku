<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Eye Animation 横持ちマスク対応</title>
<style>
  html, body {
    margin: 0;
    background: black;
    overflow: hidden;
    height: 100%;
    width: 100%;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: black;
  }
</style>
</head>
<body>
<canvas id="eyeCanvas"></canvas>

<script>
const canvas = document.getElementById('eyeCanvas');
const ctx = canvas.getContext('2d');

// ---------------- Canvas サイズ調整 ----------------
function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  let w = window.innerWidth;
  let h = window.innerHeight;

  // 横持ち固定
  if (w < h) [w, h] = [h, w];

  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + "px";
  canvas.style.height = h + "px";
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr,dpr);
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', resizeCanvas);
resizeCanvas();

// ---------------- 画像ロード ----------------
function loadImages(sources, callback) {
  let loaded = 0;
  const imgs = {};
  for (let key in sources) {
    imgs[key] = new Image();
    imgs[key].src = sources[key];
    imgs[key].onload = () => {
      loaded++;
      if (loaded === Object.keys(sources).length) callback(imgs);
    };
  }
}
let siro, kuro;

// ---------------- パラメータ ----------------
const pupilScale = 1.2;
let pupilX = 0;
let pupilY = 0;
let blinkProgress = 0;
let isClosing = true;
const pupilRangeExtra = 150;
let reactingToSound = false;
let animationRunning = false;
let returnTimer = null;

// 補間関数
function easeInOutSine(t) { return -(Math.cos(Math.PI*t)-1)/2; }

// ---------------- 音声入力 ----------------
let audioContext, analyser, dataArray;
let soundThreshold = 35;

async function initMic() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(stream);
    source.connect(analyser);
    analyser.fftSize = 256;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    monitorSound();
  } catch (err) { console.error('マイクアクセス拒否:', err); }
}

function monitorSound() {
  if (!analyser) return;
  analyser.getByteFrequencyData(dataArray);
  const avg = dataArray.reduce((a,b)=>a+b,0)/dataArray.length;

  if (avg > soundThreshold && !reactingToSound) {
    reactingToSound = true;
    if (returnTimer) { clearTimeout(returnTimer); returnTimer=null; }
    animationRunning = false;
    interruptAndReact();
  }

  if (avg < soundThreshold*0.6 && reactingToSound) {
    if (!returnTimer) {
      returnTimer = setTimeout(()=>{
        moveToCenter(()=>{ reactingToSound=false; startLoop(); });
        returnTimer=null;
      }, 3000);
    }
  }

  requestAnimationFrame(monitorSound);
}

// ---------------- 描画 ----------------
function drawEye() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const centerX = canvas.width/2;
  const centerY = canvas.height/2;

  // 縦持ちなら注意メッセージ
  if (window.innerWidth < window.innerHeight) {
    ctx.fillStyle = "black";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "white";
    ctx.font = "20px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Please rotate your device", canvas.width/2, canvas.height/2);
    return;
  }

  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.rotate(-Math.PI/2); // 90度回転（反時計回り）

  // 白目
  ctx.drawImage(siro, -siro.width/2, -siro.height/2);

  // 黒目
  const kuroW = kuro.width * pupilScale;
  const kuroH = kuro.height * pupilScale;
  ctx.drawImage(kuro, pupilX - kuroW/2, pupilY - kuroH/2, kuroW, kuroH);

  // まぶた（マスク範囲再調整）
  const baseHalf = canvas.width / 2.2;       // 横持ちに合わせて width 基準
  const closeMax = canvas.width * 0.9;       // 閉じる最大値も width 基準
  const eyelidY = baseHalf + (closeMax - baseHalf) * blinkProgress;

  ctx.fillStyle="black";
  ctx.beginPath();
  ctx.moveTo(-canvas.width/2, -canvas.height/2);
  ctx.lineTo(-canvas.width/2, eyelidY - centerX);
  ctx.quadraticCurveTo(0, eyelidY - centerX + 80, canvas.width/2, eyelidY - centerX);
  ctx.lineTo(canvas.width/2, -canvas.height/2);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

// ---------------- アニメーション関数 ----------------
function blink(times=1) {
  return new Promise(resolve=>{
    let count=0;
    function close() {
      isClosing=true;
      animateBlink().then(()=>{
        isClosing=false;
        animateBlink().then(()=>{
          count++;
          if(count<times) setTimeout(close,400);
          else { blinkProgress=0; drawEye(); resolve(); }
        });
      });
    }
    close();
  });
}

function animateBlink() {
  return new Promise(resolve=>{
    const duration=400;
    const start=performance.now();
    function step(time){
      if(reactingToSound) return resolve();
      const t=Math.min((time-start)/duration,1);
      blinkProgress = isClosing ? easeInOutSine(t) : easeInOutSine(1-t);
      drawEye();
      if(t<1) requestAnimationFrame(step);
      else resolve();
    }
    requestAnimationFrame(step);
  });
}

function moveEyes() {
  return new Promise(resolve=>{
    const range = ((siro.width/2)+pupilRangeExtra) * 0.7;
    const duration=4000;
    const repeats=2;
    let count=0;
    let direction=1;

    function animate(direction){
      const startX=pupilX;
      const endX=direction*range;
      const startTime=performance.now();

      function step(time){
        if(reactingToSound) return resolve();
        const progress=Math.min((time-startTime)/duration,1);
        pupilX = startX + (endX-startX)*easeInOutSine(progress);
        drawEye();
        if(progress<1) requestAnimationFrame(step);
        else{
          setTimeout(()=>{
            count++;
            if(count<repeats*2) animate(-direction);
            else moveToCenter(resolve);
          },1000);
        }
      }
      requestAnimationFrame(step);
    }
    animate(direction);
  });
}

function moveToCenter(callback){
  const startX=pupilX;
  const startY=pupilY;
  const duration=1500;
  const startTime=performance.now();

  function step(time){
    const progress=Math.min((time-startTime)/duration,1);
    pupilX = startX*(1-easeInOutSine(progress));
    pupilY = startY*(1-easeInOutSine(progress));
    drawEye();
    if(progress<1) requestAnimationFrame(step);
    else if(callback) callback();
  }
  requestAnimationFrame(step);
}

function interruptAndReact(){
  const startY = pupilY;
  const endY = kuro.height * 0.3;
  const duration = 600;
  const startTime = performance.now();

  function step(time){
    const progress = Math.min((time-startTime)/duration,1);
    pupilY = startY + (endY-startY)*easeInOutSine(progress);
    drawEye();
    if(progress < 1 && reactingToSound) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// ---------------- アニメーションパターン ----------------
async function playPatternB(){ 
  await blink(1); 
  await moveEyes(); 
  await new Promise(r=>setTimeout(r,3000));
}
async function playPatternC(){ 
  await blink(1); 
  drawEye();
  await new Promise(r=>setTimeout(r,3000));
}

async function startLoop(){
  if(animationRunning || reactingToSound) return;
  animationRunning=true;
  drawEye();
  const next = Math.random() < 0.5 ? playPatternB : playPatternC;
  await next();
  animationRunning=false;
  if(!reactingToSound) setTimeout(startLoop,1000);
}

// ---------------- 初期起動 ----------------
loadImages({siro:"siro.png", kuro:"kuro.png"}, (imgs)=>{
  siro = imgs.siro;
  kuro = imgs.kuro;
  drawEye();
  initMic();
  startLoop();
});
</script>
</body>
</html>
